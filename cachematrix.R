## Suppose that you have computed the inverse of a matrix in a function called
## ComputeInverse, but you also need that inverse for other functions. You may
## say "just put in the same code that computes the inverse into every function",
## which works fine for 2X2, 5X5, and even for 100X100 matrices. However, 
## 10,000X10,000 matrices are a different story. It would be useful to have a 
## way to just remember what the inverse is without having to do the same 
## time-consuming(even for the machine) calculations a million times. R doesn't 
## have 'static' variables like in Java or C++, nor does something similar exist
## in R. The clever method shown in this program seems to be the only way for R 
## to "archive" uses of ComputeInverse so that if you need the inverse of a 
## 10,000X10,000 matrix for many different functions, it only needs to be 
## actually computed once.

## The makeCacheMatrix function is what allows R to create an "archive" of 
## calculations it has already done. makeCacheMatrix returns a list of functions
## that recall the argument(which must be a matrix) and what its inverse is. It
## is vitally important to store makeCacheMatrix into a variable; otherwise,
## nothing will be archived.

makeCacheMatrix <- function(x) 
{
  inv <- NULL
  setmtrx <- function(y=matrix())
  {
    y<<-x
    inv<<-NULL
  }
  getmtrx <- function() x
  setinv <- function(inverse) inv<<-inverse
  getinv <- function() inv
  list(getmtrx=getmtrx, setmtrx=setmtrx, setinv=setinv, getinv=getinv)
}


## This function will skip calculating the inverse of a matrix if that inverse
## has already been calculated. This function requires an argument in the form
## of a list generated by makeCacheMatrix; otherwise, lines like "x$getinv" will
## make no sense to R.

cacheSolve <- function(x, ...) 
{
  inv <- x$getinv()
  if(!is.null(inv))
  {
    message("Getting cached data")
    return(inv)
  }
## If the inverse has already been calculated, x$getinv() will return something
## that isn't NULL. In that case, the if statement will evaluate to TRUE and
## return the inverse, thus skipping the steps that follow.
  mtrx <- x$getmtrx()
  inv <- solve(mtrx)
  x$setinv(inv)
  inv
}
